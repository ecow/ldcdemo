<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Sparql package documentation</title>
    <link rel="stylesheet" type="text/css" href="http://ontology.it/tools/bofw/v4/css/doc.css">
  </head>
  <body>
    <header>
      <div class="jumbotron">
        <h1>Sparql package</h1>
        <p id="subject"> An EasyRdf extension to use Guzzle to access sparql 1.1 endpoints... and more. </p>
      </div>
      <div class="metadata">
        <dl>
          <dt>Author:</dt>
          <dd id="creator">
            <address> Enrico Fagnoni - <a href="http://www.e-artspace.com/home/about">E-Artspace</a> </address>
          </dd>
          <!-- here other autogenerated metadata -->
        </dl>
      </div>
      <section id="abstract">
        <h2>Abstract</h2>
        <p> This package is part of the <a href="http://ontology.it/tools/botk/">Business Ontology ToolKit (BOTK)</a>.
        </p>
        <p> This package contains a powerful service client to access SPARQL 1.1 servers using <a href="http://guzzlephp.org/">Guzzle</a>
          as http client engine. It is compatible with <a href="http://www.easyrdf.org/">EasyRDF</a> packages and
          supports reasoning in query according <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1
            Entailment Regimes</a>.</p>
      </section>
      <section id="status">
        <h2>Package Status</h2>
        <p> Develop master branch (trunk) is changing on a daily if not hourly basis. Contributions are very welcome,
          please send them to the authors. Thank you. </p>
        <p> No stable release yet available. </p>
      </section>
      <section id="license">
        <h2>License</h2>
        <details> <summary id="rightsHolder"> Copyright © 2013 by <a href="http://www.e.artspace.com/">E-Artspace
              S.r.L.</a><sup>®</sup> GPL-3.0+ </summary>
          <p> This code is free software; you can redistribute it and/or modify it under the terms of the <a href="http://www.gnu.org/licenses/gpl.html">GNU
              General Public License</a> as published by the Free Software Foundation; either version 3.0of the License,
            or (at your option) any later version. This code is distributed in the hope that it will be useful,but
            WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
            PURPOSE. See the GNU General Public License for more details. </p>
          <p> <strong>For commercial license or others license schema, please contact <a href="http://www.e-artspace.com/">E-Artspace</a>
              or authors. </strong> </p>
        </details> </section>
    </header>
     <nav>
      <h2>Table of contents</h2>
      <!-- autogenerated toc-->
      <div id="toc"> </div>
      <!-- end of autogenerated toc--> </nav>
    <section>
      <h1 id="install">Installation</h1>
      <p> This package follows<a href="../overview/#installation"> BOTK guide line for installation</a> and require <a
          href="http://getcomposer.org/">composer</a>. </p>
      <p> Add following dependances to <strong>composer.json</strong> file in your project root: </p>
      <pre><code>{
  "require": {
    "botk/sparql": "*"
  }
}</code></pre>
    </section>
    <section>
      <h1 id="overview">Overview</h1>
      <p> Basically the goal of this library is to extend&nbsp; <a href="http://www.easyrdf.org/">EasyRDF</a><span style="color: #428bca;">
        </span>package to provide a powerful access to Sparql 1.1. serves using <a href="http://guzzlephp.org/">Guzzle</a>
        as framework to build service clients. Using Guzzle plugins it is easy to add caching, logging and backoff retry
        features in accessing sparql endpoints.</p>
      <p>Beside this, Sparql package provides an http client implementation compatible with&nbsp; Easy_Http_client that
        allows to inject Guzzle engine in EasyRdf functions. </p>
      <p>Sparql package supports reasoning in query according&nbsp; <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL
          1.1 Entailment Regimes</a> ( <a href="http://www.w3.org/TR/sparql11-entailment/#OWLRDFBSEntRegime">RDFS
          entailment Regime</a>, and&nbsp; <a href="http://www.w3.org/TR/sparql11-entailment/#OWLRDFBSEntRegime">OWL 2
          RDF-Based Semantics Entailment Regime</a>&nbsp; for&nbsp; <a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_QL">QL</a>,<a
          href="http://www.w3.org/TR/owl2-profiles/#OWL_2_RL">RL</a>, <a href="http://www.w3.org/TR/owl2-profiles/#OWL_2_EL">EL</a>
        and<span style="color: #428bca;"> </span><a href="http://www.w3.org/TR/owl2-syntax/">DL</a> profiles). It also
        supports legacy quadstore entailment regimes like SD in&nbsp; <a href="http://stardog.com/">stardog</a> and
        other popular quadstore servers. </p>
      <p> So you have two alternatives in accessing a Sparql server: </p>
      <ol>
        <li>
          <p> using EasyRdf classes </p>
          <pre><code>use BOTK\Sparql\EasyRdfUtils;

EasyRdf_Http::setDefaultHttpClient(</code><code>EasyRdfUtils::makeHttpClient</code><code><code>()</code>);

$sparql = EasyRdf_Sparq_client("http://dbpedia.org/sparql");
$solutions = $sparql-&gt;query("select * where { ?s ?p ?o } LIMIT 10");
</code></pre> </li>
        <li>
          <p> using Guzzle framework </p>
          <pre><code>use BOTK\Sparql\SparqlClient;

$sparql = </code><code><code>SparqlClient</code>::factory(array('endpoint_url' =&gt; '</code><code><code>http://dbpedia.org/sparql</code>'));
$solutions = $sparql-&gt;query(	");
</code></pre> </li>
      </ol>
      <p> Both examples use the same technologies to transport an http request to a server and to parsing results. The
        first alternative enables the access to all EasyRDF features like the GraphStore class, the second one allows
        special options to be added to a sparql query and the full access to Guzzle features like iterators (see next
        chapters). </p>
      <h1 id="ServiceClient">SparqlClient class</h1>
      <h2 id="commands">Guzzle Client Commands</h2>
      <p> This class&nbsp; uses <a href="http://docs.guzzlephp.org/en/latest/webservice-client/webservice-client.html">Guzzle
          Service utilities</a> and drives a set of commands to support a SPARQL 1.1 Query and Update protocols. </p>
      <dl>
        <dt>rawQueryCmd</dt>
        <dd> sends to sparql endpoint a query command (SELECT | CONSTRUCT | ASK | DESCRIBE) contained in the mandatory
          parameter <em>query</em> . It returns the body of the server response without any further parsing. You can
          optionally specify preferences in content negotiation using the <em>accept</em> parameter. </dd>
        <dt>queryCmd</dt>
        <dd> like rawQuery, but the response is parsed like in <code> EasyRdf_Sparql_Client::query() </code> method.
          That is that ASK queries return boolean, DESCRIBE and CONSTRUCT queries return an EasyRdf_Graph, SELECT
          queries return EasyRdf_Sparql_Result. You can also use Guzzle <a href="http://docs.guzzlephp.org/en/latest/iterators/resource-iterators.html">resource
            Iterators</a> with this command. See below for more info. </dd>
        <dt>updateCmd</dt>
        <dd> sends to the&nbsp; sparql endpoint all Update protocol commands (Load | Clear | Drop | Add | Move | Copy |
          Create | InsertData | DeleteData | DeleteWhere | Modify). Just returns server response.</dd>
      </dl>
      <p> All commands accept following options:</p>
      <ul>
        <li> <em>default_backoff_factory</em>: should contain a closure that creates an instance of a <a href="http://docs.guzzlephp.org/en/latest/plugins/backoff-plugin.html">Guzzle
            BackoffPlugin</a> . If <code> null </code> or not specified, commands call the default static method <code>
            SparqlClient::getDefaultBackoff()</code>. It creates an exponential timed backoff policy for retry max 3
          times before rising an error. Set it to <code> false </code> to disable default backoff processing. </li>
        <li> <em>namespaces</em>: an associative array of prefix=&gt;uri. If the option is present, it will be merge
          with the output of <code> EasyRdf_Namespace:namespaces() </code> method and added to any sparql query
          prologue. </li>
        <li> <em>reasoning_profile</em>: allows to specify a preferred <a href="#entailmentRegime">entailment regime</a>
          for reasoning. </li>
      </ul>
      <p> SparqlClient requires the mandatory parameter <em>endpoint_url</em> that contains the url of sparql server to
        witch sending commands. </p>
      <p> Finally you can use any valid Guzzle <a href="http://docs.guzzlephp.org/en/latest/http-client/client.html#configuration-options">Http
          Client Configuration options</a> in SparqlClient options. </p>
      <p> This example creates a sparql client connected to http://example.org/sparql server. All subsequent requests to
        this server will be authorized with basic http schema and can you will enabled to use myns: namespace prefix in
        any query: </p>
      <pre><code>use BOTK\Sparql\</code><code><code>SparqlClient</code>;

$options = array (
  'endpoint_url' =&gt; 'http://example.org/sparql',
  'request.options' =&gt; array(
      'auth' =&gt; array('username', 'password', 'Basic')
  )
  'command.options' =&gt; array(
      'namespaces' =&gt; array('myns' =&gt; 'http://example.org/ns#')
  )
);

// Create a new sparql client:
$sparql = SparqlClient::factory($options);

//call a sparql query command:
$solutions = $sparql-&gt;getCommand('queryCmd', array( 
   'query' =&gt; 'select * where { ?s myns:someproperties ?o } LIMIT 10'
))-&gt;execute();</code></pre>
      <h2 id="iterators">Iterators</h2>
      <p> SPARQL 1.1. query allows resource pagination in solution modifiers using limit and offset clauses. Some sparql
        servers can impose an hard limit to the number of returned solutions; this requires the end-user to issue a
        series of consecutive sparql query in order to fetch all of the data they asked for. Users of SparqlService
        client should not be responsible for implementing the logic involved in iterating through pages of results:
        Guzzle iterators can be used with the <span style="font-weight: bold;">queryCmd</span> command in order to
        automate the process of scanning a large number of resources without wasting memory. </p>
      <pre><code>$sparql = SparqlClient::factory(array('endpoint_url' =&gt; 'http://dbpedia.org/sparql'));

$cmdOptions = array(
    'query'  =&gt; 'select * where { ?s ?p ?o }',
);
$iteratorOptions = array(
    'limit'              =&gt; 10000,    // use 0 for no limits
    'page_size'          =&gt; 300       // grab 300 resurces for each sparq request
    'offset'             =&gt; 0,        // starting from first triple in troplestore
    'payload_size'       =&gt; 1000000,  // optimum size for a payload transfer (1MB)
    'autotune_page_size' =&gt; true      // dynamic optimization of page_size
);
$iterator = $sparql-&gt;getIterator('queryCmd',$cmdOptions,$iteratorOptions);

foreach ($iterator as $selectResult) {
...
}</code></pre>
      <p> Resource iterator for queryCmd accepts options : </p>
      <ul>
        <li> <em>limit</em>: to specify the maximum&nbsp; number of solution returned. If not specified it is set to
          0.&nbsp; 0 means no limits to returnd resources. This paramether should not be confused wit LIMIT clause
          inside sparql query. </li>
        <li> <em>page_size</em>: it is the numeber of resources grabbed every sparql request. It is similareto LIMIT
          clause inside the quesry. If not specified <code> SparqlClient::DEFAULT_PAGE_SIZE </code> constant is used.
          This paramether can be changed after firs iteration if <em>autotune_page_size</em> is <code> true </code> .
          <br>
        </li>
        <li> <em>payload_size</em>: to specify the preferred size of returned Response payload expressed in
          bytes.&nbsp; If not specified <code> SparqlClient::DEFAULT_PAYLOAD_SIZE </code> constant is used (i.e.
          1000000). It is used only when <em>autotune_limit</em> parameter is true. </li>
        <li> <em>noautotune_page_size</em>: if is set to <code> false </code> or not set, recomputes dynamically the
          <em>page_size</em> parameter to fullfill <em>payload_size</em>. Note that autotune&nbsp; algorithm is based
          on statistical analysis of the medium size of previous returned solutions. So it is never guaranteed that the
          effective memory footprints of the returned payload match <em>payload_size</em>. If it is set to <code> true
          </code> <em>page_size</em> will be used in all iteration. The default value is <code> false </code> . </li>
      </ul>
      <p> To be effective you should not include LIMIT or OFFSET clauses in command query or&nbsp; you will get the same
        result as calling the command without iterator. </p>
      <p> Note that DESCRIBE and CONSTRUCT queries produce a whole graph each interaction. Using iterator with a sparql
        ASK query produce the same result of a direct command call (i.e. no iteration performed). </p>
      <pre><code>$cmdOptions = array(
   'query' =&gt; 'describe ?s where { ?s ?p ?o }',
);
$iterator = $sparql-&gt;getIterator('queryCmd',$cmdOptions,$iteratorOptions);

foreach ($iterator as $graph) {
    ...scan $graph...
}</code></pre>
      <p> Resource iterator for queryCmd (i.e.<code> QueryCmdIterator</code> class) exposes the method <code>
          getIterationStats()</code> that provides statistics about sparql iterations. </p>
      <h2 id="helpers">Helpers</h2>
      <p> Beside commands, SparqlClient class exposes some helper methods: </p>
      <ul>
        <li> <code><code> SparqlClient::_(string $url)</code> : equivalent to </code>
          <pre><code>$sparql-&gt;factory(array('endpoint_url'=&gt;$url));
</code></pre> <code> Guzzle\Http\EntityBodyInterface rawQuery(string $query, string $format)</code> : equivalent to
          <pre><code>$queryCmd = $sparql-&gt;getCommand('rawQueryCmd', array(
    'query'  =&gt; $query,
    'accept' =&gt; $format
));
$entityBody = $queryCmd-&gt;execute();
</code></pre> </li>
        <li> <code> Mixed query(string $query) </code> : equivalent to
          <pre><code>$queryCmd = $sparql-&gt;getCommand('queryCmd', array(
    'query'  =&gt; $query
));
$parsedResult = $queryCmd-&gt;execute();</code></pre>
        </li>
        <li> <code> Guzzle\Http\Message\Response update(string $query) </code> : equivalent to
          <pre><code>$queryCmd = $sparql-&gt;getCommand('updateCmd', array(
    'query'  =&gt; $query
));
$response = $queryCmd-&gt;execute();</code></pre>
        </li>
        <li> <code> Guzzle\Service\Resource\ResourceIterator iQuery(string $query, int $limit=0,int
            $pageSize=SelectClienet::DEFAULT_PAGE_SIZE) </code> : equivalent to
          <pre><code>$cmdOptions = array(
    'query'  =&gt; $query,
);
$iteratorOptions = array(
    'limit'              =&gt; $limit,
    'page_size'          =&gt; $page_size,
    'offset'             =&gt; 0,
    'payload_size'       =&gt; SparqlService::DEFAULT_PAYLOAD_SIZE;
    'autotune_page_size' =&gt; true
);
$iterator = $sparql-&gt;getIterator('queryCmd',$cmdOptions,$iteratorOptions);</code></pre>
        </li>
      </ul>
      <p> Here are some helper usage examples: </p>
      <pre><code>use BOTK\Sparql\</code><code><code>SparqlClient</code>;

$sparql = SparqlClient::_('http://dbpedia.org/sparql');

echo '&lt;pre&gt;',$sparql-&gt;rawQuery('select * where { ?s ?p ?o } LIMIT 10','text/turtle'),'&lt;/pre&gt;';

$selectResults = $sparql-&gt;query('select * where { ?s ?p ?o } LIMIT 10');
foreach ($selectResults as $selectResult) { echo $selectResult; }

// get first 1000 results splitting slicing requests to not waste memory
$iterator = $sparql-&gt;iQuery('select * where { ?s ?p ?o }',1000);
foreach ($iterator as $selectResults) {</code><code><code> echo $selectResult;</code> }
</code></pre>
      <h1 id="EasyRdfUtils">EasyRdfUtils class</h1>
      <p>This class allows to integrate Guzzle http engine inside EasyRdf features that access external http resources
        like <code>Graph::load()</code> method, <code>EasyRdf_GraphStore</code> methods, <code> EasyRdf_Sparql_Client</code>
        methods.</p>
      <p><code>EasyRdfUtils::makeHttpClient()</code> builds an instance of class that is derived from
        EasyRdf_Http_Client but that internally uses Guzzle http transport. You can pass to <code>EasyRdfUtils::makeHttpClient()</code>
        the same options and defaults available for Guzzle <code>ServiceClient::factory()</code> class like in this
        example: </p>
      <pre><code>use BOTK\Sparql\EasyRdfUtils;

$httpClient=EasyRdfUtils::makeHttpClient(array(...));
EasyRdf_Http::setDefaultHttpClient($httpClient);<br></code></pre>
      <p>&nbsp; There are also available a couple shortcut helpers: </p>
      <ul>
        <li><code>EasyRdfUtils::useGuzzleClient($options=array())</code> : equivalent to
          <pre><code>EasyRdf_Http::setDefaultHttpClient(EasyRdfUtils::getHttpClient($options));</code></pre>
        </li>
        <li> <code> EasyRdfUtils::useIdentity('username','password')</code>: equivalent to
          <pre><code>EasyRdfUtils::useGuzzleClient(
   array(
       'request.options' =&gt; array('auth'  =&gt; array('username', 'password', 'Basic'))
   )
);</code></pre>
          <p> After this statement you can use any EasyRdf feature getting the benefit of very special guzzle features
            like backoff, logging, authentications and caching. </p>
        </li>
      </ul>
      <p>Please remember that <code>EasyRdf_Http::setDefaultHttpClient()</code> ( and so <code>useGuzzleClient()</code>
        and <code>useIdentity()</code> methods), affects all subsequent calls to methods of&nbsp; <code>EasyRdf_Graph</code>,
        <code>EasyRdf_GraphStore</code>&nbsp; and <code>EasyRdf_Sparql_Client</code> classes.</p>
      <ul>
      </ul>
      <h1 id="entailmentRegime">Entailment regime support</h1>
      <p> All SparqlClient commands allow to specify the required Sparql server entailment capabilities through optional
        <em>reasoningProfile</em> command parameter. This&nbsp; parameter enables to negotiate an <a href="http://www.w3.org/TR/sparql11-entailment/">entailment
          regime</a> with the quadstore engine. <code>reasoning_profile</code> accepts one of these values: </p>
      <ul>
        <li> <strong>DEFAULT</strong>: use the quadstore predefined SPARQL 1.1 reasoning entilement (default). <br>
        </li>
        <li> <strong>NONE</strong>: no inferences on SPARQL 1.1, just query about facts. </li>
        <li> <strong>RDFS</strong>: ask to&nbsp; quadstore to consider OWL 2 axioms allowed in RDF schema (mainly
          subclasses, subproperties, domain, and ranges) in evaluating SPARQL queries. </li>
        <li> <strong>QL</strong>: ask to&nbsp; quadstore to consider OWL 2 QL axioms in evaluating SPARQL queries. </li>
        <li> <strong>RL</strong>: ask to&nbsp; quadstore to consider OWL 2 RL axioms in evaluating SPARQL queries. </li>
        <li> <strong>EL</strong>: ask to&nbsp; quadstore to consider OWL 2 EL axioms in evaluating SPARQL queries. </li>
        <li> <strong>DL</strong>: ask to&nbsp; quadstore to consider OWL 2 DL axioms in evaluating SPARQL queries. </li>
        <li> <strong>SL</strong>: ask to&nbsp; quadstore to consider&nbsp; <a href="http://stardog.com/">stardog</a>&nbsp;
          legacy entilement profile that is a combination of RDFS, QL, RL, and EL axioms, plus SWRL rules. </li>
      </ul>
      <p> Note that there is no standard means to know if the remote sparql endpoint is able to accomplish reasoning
        request. You must trust on quadstore reasoning capabilities documented out-of-band by the end-point. </p>
      <p> You can use <em>reasoningProfile</em> also with EasyRdf interface: </p>
      <pre><code>EasyRdfUtils::useGuzzleClient(array (
  'endpoint_url' =&gt; 'http://example.org/sparql',
  'command.options' =&gt; array(
      'reasoning_profile' =&gt; 'RDFS'
));

$selectResults=$sparql-&gt;query('SELECT * WHERE {?s a ?type} LIMIT 10');

</code></pre>
      <p> Some SPARQL query can be illegal in some entailment regimes in particular quadstore implementations and
        resulting in an error. For instance DL entailment regime is supported by of stardog 2.0.3 just for query base
        graph pattern (BGP) that contains only TBox() statements; it generated an error if query contains ABox
        statements. </p>
      <p> <strong>As a matter of fact you must know, before query, if the sparql server allows you the access to
          required entailment regime.</strong> </p>
      <p> This table summarizes support to various entailment regimes in some quadstore engine (BOTK validation about
        server conformance to W3C specifications is still in progress): </p>
      <table style="width: 100%" border="1">
        <thead>
          <tr>
            <td style="text-align: right;">entailment/quadstore</td>
            <th><a href="https://github.com/semsol/arc2/wiki">ARC2</a></th>
            <th><a href="http://virtuoso.openlinksw.com/">Open Link Virtuoso</a></th>
            <th><a href="http://www.franz.com/agraph/">Allegro Graph</a></th>
            <th><a href="http://stardog.com/">Stardog</a></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>DEFAULT</th>
            <td>Just SPARQL 1.0</td>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
          </tr>
          <tr>
            <th>NONE</th>
            <td>Just SPARQL 1.0</td>
            <td>OK</td>
            <td>OK</td>
            <td>OK</td>
          </tr>
          <tr>
            <th>RDFS</th>
            <td>NO</td>
            <td>?</td>
            <td>?</td>
            <td>OK</td>
          </tr>
          <tr>
            <th>QL</th>
            <td>NO</td>
            <td>?</td>
            <td>?</td>
            <td>No equality support</td>
          </tr>
          <tr>
            <th>RL</th>
            <td>NO</td>
            <td>?</td>
            <td>?</td>
            <td>No equality support</td>
          </tr>
          <tr>
            <th>DL</th>
            <td>NO</td>
            <td>?</td>
            <td>?</td>
            <td>Just on Tbox BGP via Pellet</td>
          </tr>
          <tr>
            <th>SL (stardog legacy)</th>
            <td>NO</td>
            <td>NO</td>
            <td>NO</td>
            <td>OK</td>
          </tr>
        </tbody>
      </table>
      <p> <br>
      </p>
      Current SparqlClient implementation supports reasoning only with <a href="http://stardog.com/">stardog</a>&nbsp;
      quadstore. </section>
    <section>
      <h1 id="credits">External packages and credits</h1>
      <p> Sparql package uses some great libraries: </p>
      <h3>EasyRDF</h3>
      <p> <a href="http://www.easyrdf.org/">EasyRDF</a> is a PHP library designed to make it easy to consume and
        produce RDF. Designed for use in mixed teams of experienced and inexperienced RDF developers. Written in PSR-2
        compliant PHP and tested extensively using PHPUnit. </p>
      <h4>License</h4>
      <p> Copyright (c) 2009-2011 Nicholas J Humfrey. All rights reserved. </p>
      <p> Redistribution and use in source and binary forms, with or without modification, are permitted provided that
        the following conditions are met: </p>
      <ul>
        <li> Redistributions of source code must retain the above copyright notice, this list of conditions and the
          following disclaimer. </li>
        <li> Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
          following disclaimer in the documentation and/or other materials provided with the distribution. </li>
        <li> The name of the author 'Nicholas J Humfrey" may be used to endorse or promote products derived from this
          software without specific prior written permission. </li>
      </ul>
      <p> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
        WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
        PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY
        DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
        DAMAGE. </p>
      <h3>Guzzle</h3>
      <p> Guzzle takes the pain out of sending HTTP requests and the redundancy out of creating web service clients.
        It's a framework that includes the tools needed to create a robust web service client, including: Service
        descriptions for defining the inputs and outputs of an API, resource iterators for traversing paginated
        resources, batching for sending a large number of requests as efficiently as possible. </p>
      <h4>License</h4>
      <p> Copyright (c) 2011 Michael Dowling, https://github.com/mtdowling &lt;mtdowling@gmail.com&gt; <br>
        <br>
        Permission is hereby granted, free of charge, to any person obtaining a copy <br>
        of this software and associated documentation files (the "Software"), to deal <br>
        in the Software without restriction, including without limitation the rights <br>
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell <br>
        copies of the Software, and to permit persons to whom the Software is <br>
        furnished to do so, subject to the following conditions: <br>
        <br>
        The above copyright notice and this permission notice shall be included in <br>
        all copies or substantial portions of the Software. <br>
        <br>
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR <br>
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, <br>
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE <br>
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER <br>
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, <br>
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN <br>
        THE SOFTWARE. <br>
      </p>
    </section>
    <!-- autogenerated footer -->
    <!-- end of autogenerated footer -->
  </body>
</html>
